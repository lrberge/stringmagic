<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>String tools: magic edition • fixest</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="String tools: magic edition">
<meta property="og:description" content="stringmagic">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">fixest</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">1.0.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/stringmagic_tour.html">`stringmagic`: A quick tour</a>
    </li>
    <li class="divider">
    </li>
<li class="dropdown-header">Guides</li>
    <li>
      <a href="../articles/smagic_walkthrough.html">`smagic`: Magical string interpolation</a>
    </li>
    <li>
      <a href="../articles/string_tools.html">String tools: magic edition</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/lrberge/stringmagic/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>String tools: magic edition</h1>
                        <h4 data-toc-skip class="author">Laurent R.
Bergé</h4>
            
            <h4 data-toc-skip class="date">2023-06-25</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/lrberge/stringmagic/blob/HEAD/vignettes/string_tools.rmd" class="external-link"><code>vignettes/string_tools.rmd</code></a></small>
      <div class="hidden name"><code>string_tools.rmd</code></div>

    </div>

    
    
<p>This vignette describes <code>stringmagic</code> tools for handling
character vectors. For a quick start, here are the sections
describing:</p>
<ul>
<li>how to <a href="#detect_funs">detect complex regex (=regular
expression) patterns</a>
</li>
<li>how to easily, and clearly, <a href="#sec_ops">chain multiple string
operations</a>
</li>
<li>how to efficiently, and clearly, <a href="#sec_clean">clean
character strings</a>
</li>
</ul>
<p>This vignette is also a reference for i) the <a href="#sec_regex">optional regex flags</a> available to all
<code>stringmagic</code> regular expressions, and ii) the <a href="#detect_logic">logical combination of regular expressions</a>.</p>
<div class="section level2">
<h2 id="sec_regex">Regex flags<a class="anchor" aria-label="anchor" href="#sec_regex"></a>
</h2>
<p>All functions in <code>stringmagic</code> accept optional regex flags
when regular expressions are expected. The idea is similar to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions#advanced_searching_with_flags" class="external-link">regular
regex flags</a>, but the flags are different in name and effect.</p>
<div class="section level3">
<h3 id="regex-flags-syntax">Regex flags: Syntax<a class="anchor" aria-label="anchor" href="#regex-flags-syntax"></a>
</h3>
<p>Use <code>"flag1, flag2/regex"</code> to add the flags
<code>flag1</code> and <code>flag2</code> to the regular expression
<code>regex</code>. For example <code>"ignore, fixed/dt["</code> will
add the flags <code>ignore</code> and <code>fixed</code> to the regex
<code>dt[</code>.</p>
<p>Alternatively, use only the initials of the flags. Hence,
<code>"if/dt["</code> would also add the flags <code>ignore</code> and
<code>fixed</code>.</p>
<p>If the regex does not contain a slash (<code>/</code>), no flags are
added. If your regex should contain a slash, see the <a href="#flag_escaping">section on escaping</a>.</p>
<p>Ex: let’s find lines containing <code>"dt["</code>:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">code</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"DT = as.data.table(iris)"</span>, </span>
<span>         <span class="st">"DT[, .(pl_sl = smagic('PL/SL = {Petal.Length / Sepal.Length}')]"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="../reference/str_get.html">str_get</a></span><span class="op">(</span><span class="va">code</span>, <span class="st">"if/dt["</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "DT[, .(pl_sl = smagic('PL/SL = {Petal.Length / Sepal.Length}')]"</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="regex-flags-reference">Regex flags: Reference<a class="anchor" aria-label="anchor" href="#regex-flags-reference"></a>
</h3>
<p>The available flags are:</p>
<ul>
<li>
<a href="#flag_ignore">ignore</a>: always available</li>
<li>
<a href="#flag_fixed">fixed</a>: always available</li>
<li>
<a href="#flag_word">word</a>: always available</li>
<li>
<a href="#flag_magic">magic</a>: always available</li>
<li>
<a href="#flag_total">total</a>: only available in functions
performing a replacement</li>
<li>
<a href="#flag_single">single</a>: only available in functions
performing a replacement</li>
</ul>
<div class="section level4">
<h4 id="flag_ignore">ignore<a class="anchor" aria-label="anchor" href="#flag_ignore"></a>
</h4>
<p>The flag <code>"ignore"</code> leads to a case-insensitive
search.</p>
<p>Ex: let’s extract words starting with the last letters of the
alphabet.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">unhappy</span> <span class="op">=</span> <span class="st">"Rumble thy bellyful! Spit, fire! spout, rain!</span></span>
<span><span class="st">Nor rain, wind, thunder, fire are my daughters.</span></span>
<span><span class="st">I tax not you, you elements, with unkindness.</span></span>
<span><span class="st">I never gave you kingdom, call'd you children,</span></span>
<span><span class="st">You owe me no subscription. Then let fall</span></span>
<span><span class="st">Your horrible pleasure. Here I stand your slave,</span></span>
<span><span class="st">A poor, infirm, weak, and despis'd old man."</span></span>
<span></span>
<span><span class="co"># the ignore flag allows to retain words starting with the</span></span>
<span><span class="co"># upper cased letters</span></span>
<span><span class="co"># ex: getting words starting with the letter 'r' to 'z'</span></span>
<span><span class="fu">smagic</span><span class="op">(</span><span class="st">"{'i/\\b[r-z]\\w+'extract, c, 60 width ? unhappy}"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Rumble thy Spit spout rain rain wind thunder tax you you\nwith unkindness you you You subscription Then Your stand\nyour slave weak"</span></span></code></pre></div>
<p><em>Technically</em>, the <a href="https://www.pcre.org/" class="external-link">perl</a>
expression <code>"(?i)"</code> is added at the beginning of the
pattern.</p>
</div>
<div class="section level4">
<h4 id="flag_fixed">fixed<a class="anchor" aria-label="anchor" href="#flag_fixed"></a>
</h4>
<p>The flag <code>"fixed"</code> removes any special regular expression
meaning from the pattern, and treats it as verbatim.</p>
<p>Ex: let’s fix the equation by changing the operators.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">x</span> <span class="op">=</span> <span class="st">"50 + 5 * 5 = 40"</span></span>
<span><span class="fu"><a href="../reference/str_clean.html">str_clean</a></span><span class="op">(</span><span class="va">x</span>, <span class="st">"f/+, * =&gt; -"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "50 - 5 - 5 = 40"</span></span>
<span></span>
<span><span class="co"># Without the fixed flag, we would have gotten an error since '+' or '*'</span></span>
<span><span class="co"># have a special meaning in regular expressions and expects something before</span></span>
<span></span>
<span><span class="co"># Here's the error</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/try.html" class="external-link">try</a></span><span class="op">(</span><span class="fu"><a href="../reference/str_clean.html">str_clean</a></span><span class="op">(</span><span class="va">x</span>, <span class="st">"+, * =&gt; -"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; Error : in str_clean(x, "+, * =&gt; -"): </span></span>
<span><span class="co">#&gt; CONTEXT: evaluation of "+, * =&gt; -"</span></span>
<span><span class="co">#&gt;          pattern     = "+" </span></span>
<span><span class="co">#&gt;          replacement = "-"</span></span>
<span><span class="co">#&gt; EXPECTATION: the pattern must be a valid regular expression</span></span>
<span><span class="co">#&gt; PROBLEM: `gsub` led to an error, see below:</span></span>
<span><span class="co">#&gt; invalid regular expression '+'</span></span>
<span><span class="co">#&gt; PCRE pattern compilation error</span></span>
<span><span class="co">#&gt;  'quantifier does not follow a repeatable item'</span></span>
<span><span class="co">#&gt;  at '+'</span></span></code></pre></div>
<p><em>Technically</em>, if <code>"fixed"</code> is the only flag, then
the functions <code><a href="https://rdrr.io/r/base/grep.html" class="external-link">base::grepl</a></code> or <code><a href="https://rdrr.io/r/base/grep.html" class="external-link">base::gsub</a></code> are
run with the argument <code>fixed = TRUE</code>. If there are also the
flags <code>"ignore"</code> or <code>"word"</code>, the pattern is
nested into the perl boundaries <code>\\Q</code> and <code>\\E</code>
which strip any special meaning from the pattern.</p>
</div>
<div class="section level4">
<h4 id="flag_word">word<a class="anchor" aria-label="anchor" href="#flag_word"></a>
</h4>
<p>The flag <code>"word"</code>:</p>
<ul>
<li>adds word boundaries to the pattern</li>
<li>accepts comma-separated enumerations of words which are concatenated
with a logical ‘or’</li>
</ul>
<p>The logic of accepting comma-separated enumerations is to increase
readability. For example, with the flag <code>"word"</code>,
<code>"is, are, were"</code> is equivalent to
<code>"\\b(is|are|were)\\b"</code>.</p>
<p>Ex: we hide a few words from Alfred de Vigny’s poem.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">le_mont_des_oliviers</span> <span class="op">=</span> <span class="st">"S'il est vrai qu'au Jardin sacré des Écritures,</span></span>
<span><span class="st">Le Fils de l'homme ai dit ce qu'on voit rapporté ;</span></span>
<span><span class="st">Muet, aveugle et sourd au cri des créatures,</span></span>
<span><span class="st">Si le Ciel nous laissa comme un monde avorté,</span></span>
<span><span class="st">Alors le Juste opposera le dédain à l'absence</span></span>
<span><span class="st">Et ne répondra plus que par un froid silence</span></span>
<span><span class="st">Au silence éternel de la Divinité."</span></span>
<span></span>
<span><span class="co"># we hide a few words from this poem</span></span>
<span><span class="fu">smagic</span><span class="op">(</span><span class="st">"{'wi/et, le, il, au, des?, ce =&gt; _'r ? le_mont_des_oliviers}"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "S'_ est vrai qu'_ Jardin sacré _ Écritures,\n_ Fils _ l'homme ai dit _ qu'on voit rapporté ;\nMuet, aveugle _ sourd _ cri _ créatures,\nSi _ Ciel nous laissa comme un monde avorté,\nAlors _ Juste opposera _ dédain à l'absence\n_ ne répondra plus que par un froid silence\n_ silence éternel _ la Divinité."</span></span></code></pre></div>
<p><em>Technically</em>, first the pattern is split with respect to
<code>",[ \t\n]+"</code>, then all elements are collapsed with
<code>"|"</code>. If the flag <code>"fixed"</code> was also present,
each element is first wrapped into <code>"\\Q"</code> and
<code>"\\E"</code>. Finally, we add parentheses (to enable capture) and
word boundaries (<code>"\\b"</code>) on both sides.</p>
</div>
<div class="section level4">
<h4 id="flag_magic">magic<a class="anchor" aria-label="anchor" href="#flag_magic"></a>
</h4>
<p>The flag <code>"magic"</code> allows the user to interpolate
variables inside the regular expression before the regex is
evaluated.</p>
<p>Ex: interpolating variables inside regular expressions.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vowels</span> <span class="op">=</span><span class="st">"aeiouy"</span></span>
<span><span class="co"># let's keep only the vowels</span></span>
<span><span class="co"># we want the pattern: "[^aeiouy]"</span></span>
<span><span class="va">lmb</span> <span class="op">=</span> <span class="st">"'Tis safer to be that which we destroy</span></span>
<span><span class="st">Than by destruction dwell in doubtful joy."</span></span>
<span><span class="fu"><a href="../reference/str_clean.html">str_clean</a></span><span class="op">(</span><span class="va">lmb</span>, <span class="st">"magic/[^{vowels}] =&gt; _"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "__i___a_e___o__e___a____i____e__e___oy___a___y__e___u__io____e___i___ou___u___oy_"</span></span>
<span></span>
<span><span class="co">#</span></span>
<span><span class="co"># Illustration of `smagic` operations before regex application</span></span>
<span></span>
<span><span class="va">cars</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/row.names.html" class="external-link">row.names</a></span><span class="op">(</span><span class="va">mtcars</span><span class="op">)</span></span>
<span><span class="co"># Which of these models contain a digit?</span></span>
<span><span class="va">models</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Toyota"</span>, <span class="st">"Hornet"</span>, <span class="st">"Porsche"</span><span class="op">)</span></span>
<span><span class="co"># we want the pattern "(Toyota|Hornet|"Porsche).+\\d"</span></span>
<span><span class="co"># we collapse the models with a pipe using '|'c</span></span>
<span><span class="fu"><a href="../reference/str_get.html">str_get</a></span><span class="op">(</span><span class="va">cars</span>, <span class="st">"m/({'|'c?models}).+\\d"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Hornet 4 Drive" "Porsche 914-2"</span></span>
<span></span>
<span><span class="co"># alternative: same as above but we first comma-split the vector</span></span>
<span><span class="va">models_comma</span> <span class="op">=</span> <span class="st">"Toyota, Hornet, Porsche"</span></span>
<span><span class="fu"><a href="../reference/str_get.html">str_get</a></span><span class="op">(</span><span class="va">cars</span>, <span class="st">"m/({S, '|'c?models_comma}).+\\d"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Hornet 4 Drive" "Porsche 914-2"</span></span>
<span></span>
<span><span class="co">#</span></span>
<span><span class="co"># Interpolation does not apply to regex-specific curly brackets</span></span>
<span></span>
<span><span class="co"># We delete only successions of 2+ vowels</span></span>
<span><span class="co"># {2,} has a rexex meaning and is not interpolated:</span></span>
<span><span class="fu"><a href="../reference/str_clean.html">str_clean</a></span><span class="op">(</span><span class="va">lmb</span>, <span class="st">"magic/[{vowels}]{2,} =&gt; _"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "'Tis safer to be that which we destr_\nThan by destruct_n dwell in d_btful j_."</span></span></code></pre></div>
<p><em>Technically</em>, the algorithm does not interpolate curly
brackets having a regular expression meaning. The expression of the form
<code>"{a, b}"</code> with <code>"a"</code> and <code>"b"</code> digits
means a repetition of the previous symbol of at least <code>"a"</code>
times and at most <code>"b"</code> times. The variables are fetched in
the calling environment. To obtain fetch them from a different location,
you can use the argument <code>envir</code>.</p>
</div>
<div class="section level4">
<h4 id="flag_total">total<a class="anchor" aria-label="anchor" href="#flag_total"></a>
</h4>
<p>The flag <code>"total"</code> is only available to functions
performing a replacement. In that case, if a pattern is detected,
<em>the full character string</em> is replaced (instead of just the
pattern).</p>
<p>Ex: let’s replace a few car models.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cars_small</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/row.names.html" class="external-link">row.names</a></span><span class="op">(</span><span class="va">mtcars</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">cars_small</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Mazda RX4"         "Mazda RX4 Wag"     "Datsun 710"       </span></span>
<span><span class="co">#&gt; [4] "Hornet 4 Drive"    "Hornet Sportabout" "Valiant"</span></span>
<span></span>
<span><span class="fu"><a href="../reference/str_clean.html">str_clean</a></span><span class="op">(</span><span class="va">cars_small</span>, <span class="st">"ti/mazda =&gt; Mazda: sold out!"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Mazda: sold out!"  "Mazda: sold out!"  "Datsun 710"       </span></span>
<span><span class="co">#&gt; [4] "Hornet 4 Drive"    "Hornet Sportabout" "Valiant"</span></span></code></pre></div>
<p>On top of this, the <code>"total"</code> flag allows to perform
logical operations across several regex patterns. You have more
information on this in the <a href="#detect_logic">dedicated
section</a>. In a nutshell, you can write
<code>"pat1 &amp; !pat2 | pat3"</code> with <code>"patx"</code> regular
expresion patterns. This means: contains <code>pat1</code> and does not
contain <code>pat2</code>, or contains <code>pat3</code>.</p>
<p>Ex: detect car brands with a digit and no ‘e’.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cars_small</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/row.names.html" class="external-link">row.names</a></span><span class="op">(</span><span class="va">mtcars</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">cars_small</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Mazda RX4"         "Mazda RX4 Wag"     "Datsun 710"       </span></span>
<span><span class="co">#&gt; [4] "Hornet 4 Drive"    "Hornet Sportabout" "Valiant"</span></span>
<span></span>
<span><span class="fu"><a href="../reference/str_clean.html">str_clean</a></span><span class="op">(</span><span class="va">cars_small</span>, <span class="st">"ti/\\d &amp; !e =&gt; I don't like that brand!"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "I don't like that brand!" "I don't like that brand!"</span></span>
<span><span class="co">#&gt; [3] "I don't like that brand!" "Hornet 4 Drive"          </span></span>
<span><span class="co">#&gt; [5] "Hornet Sportabout"        "Valiant"</span></span></code></pre></div>
<p><em>Technically</em>, instead of using <code>gsub</code> to replace
the pattern, <a href="#detect_funs"><code>str_is</code></a> is used to
detect which element contains the pattern. Each element with the pattern
is then substituted with the replacement.</p>
</div>
<div class="section level4">
<h4 id="flag_single">single<a class="anchor" aria-label="anchor" href="#flag_single"></a>
</h4>
<p>The flag <code>"single"</code> is only available to functions
performing a replacement. It allows only a single substitution to take
place. Said differently, only the first replacement is performed.</p>
<p>Ex: single substitutions.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">encounter</span> <span class="op">=</span> <span class="fu"><a href="../reference/str_vec.html">str_vec</a></span><span class="op">(</span><span class="st">"Hi Cyclops., Hi you. What's your name?, Odysseus is my name."</span><span class="op">)</span></span>
<span><span class="co"># we only remove the first word</span></span>
<span><span class="fu"><a href="../reference/str_clean.html">str_clean</a></span><span class="op">(</span><span class="va">encounter</span>, <span class="st">"single/\\w+ =&gt; ..."</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "... Cyclops."               "... you. What's your name?"</span></span>
<span><span class="co">#&gt; [3] "... is my name."</span></span></code></pre></div>
<p><em>Technically</em>, the function <code><a href="https://rdrr.io/r/base/grep.html" class="external-link">base::sub</a></code> is used
instead of <code><a href="https://rdrr.io/r/base/grep.html" class="external-link">base::gsub</a></code>.</p>
</div>
</div>
<div class="section level3">
<h3 id="flag_escaping">Escaping flags: How to, and a word of caution with paths<a class="anchor" aria-label="anchor" href="#flag_escaping"></a>
</h3>
<p>If your regular expression contains a slash (<code>"/"</code>), this
will come in conflict with the parsing of the optional flags. At the
moment a <code>/</code> is present in a pattern, the algorithm will
throw an error if the expected flags are not written correctly.</p>
<p>To use a slash in the regex without adding flags there are two
solutions:</p>
<ul>
<li>start the pattern with a <code>"/"</code>. This is considered the
empty flag and will be discared.</li>
<li>escape the first <code>"/"</code> with a double backslash</li>
</ul>
<p>Ex: let’s invert the numerator and denominator of a division.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">eq</span> <span class="op">=</span> <span class="st">"5/x = 3/2"</span></span>
<span><span class="co"># a) escaping with empty flags</span></span>
<span><span class="fu"><a href="../reference/str_clean.html">str_clean</a></span><span class="op">(</span><span class="va">eq</span>, <span class="st">"/(\\d)/(\\w) =&gt; \\2/\\1"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "x/5 = 2/3"</span></span>
<span></span>
<span><span class="co"># b) escaping with backslashes</span></span>
<span><span class="fu"><a href="../reference/str_clean.html">str_clean</a></span><span class="op">(</span><span class="va">eq</span>, <span class="st">"(\\d)\\/(\\w) =&gt; \\2/\\1"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "x/5 = 2/3"</span></span></code></pre></div>
<p><strong>Warning:</strong> when applying regular expressions on file
paths, the escaping of the slash can be highly confusing. This is a
limitation of the current implementation of the optional flags. For
example <code>"/[^/]+$"</code> looks like a legit regex to get the
parent folder, but it won’t work as expected within
<code>stringmagic</code>. To behave as expected, you would need to write
<code>"//[^/]+$"</code> which looks weird, or
<code>"\\/[^/]+$"</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="intuivite-detection-of-regex-patterns">Intuivite detection of regex patterns<a class="anchor" aria-label="anchor" href="#intuivite-detection-of-regex-patterns"></a>
</h2>
<p>Detecting a single regex pattern is pretty straightforward with
regular tools like <code><a href="https://rdrr.io/r/base/grep.html" class="external-link">base::grepl</a></code> or
<code><a href="https://stringr.tidyverse.org/reference/str_detect.html" class="external-link">stringr::str_detect</a></code>. Things become more complicated when we
want to detect the presence of multiple patterns.</p>
<p><code>stringmagic</code> offers three functions with an intuitive
syntax to deal with complex pattern detection:</p>
<ul>
<li>
<a href="#detect_funs">str_is</a>: returns a logical vector</li>
<li>
<a href="#detect_funs">str_which</a>: returns the indexes of the
matches</li>
<li>
<a href="#detect_funs">str_get</a>: returns the matches</li>
</ul>
<p>As described in the next section., these tools benefit from a
streamlined syntax to logically combine several regex patterns.</p>
<div class="section level3">
<h3 id="detect_logic">Logically combining regex patterns<a class="anchor" aria-label="anchor" href="#detect_logic"></a>
</h3>
<p>Assume <code>"pat1"</code> and <code>"pat2"</code> are two regular
expression patterns and we want to test whether the string
<code>x</code> contains a combination of these patterns. Then:</p>
<ul>
<li>
<code>"pat1 &amp; pat2"</code> = <code>x</code> contains
<code>pat1</code> AND <code>x</code> contains <code>pat2</code>
</li>
<li>
<code>"pat1 | pat2"</code> = <code>x</code> contains
<code>pat1</code> OR <code>x</code> contains <code>pat2</code>
</li>
<li>
<code>"!pat1"</code> = <code>x</code> does not contain
<code>pat1</code>
</li>
<li>
<code>"!pat1 &amp; pat2"</code> = <code>x</code> does not contain
<code>pat1</code> AND <code>x</code> contains <code>pat2</code>
</li>
</ul>
<p>Hence the three logial operators are:</p>
<ul>
<li>
<code>" &amp; "</code>: logical AND, it <strong>must</strong> be a
space + an ampersand + a space (just the <code>&amp;</code> does not
work)</li>
<li>
<code>" | "</code>: logical OR, it <strong>must</strong> be a space
+ a pipe + a space (just the <code>|</code> does not work)</li>
<li>
<code>"!"</code>: logical NOT, it works only when it is the first
character of the pattern. Note that anything after it (including spaces
and other <code>!</code>) <em>is part of the regular
expression</em>
</li>
</ul>
<p>The parsing of the logical elements is done before any regex
interpretation. The logical evaluations are done from left to right and
are sequentially combined.</p>
<p>You <strong>cannot</strong> combine logical statements with
parentheses.</p>
<p>For example: <code>"hello | (world &amp; my lady)"</code> leads to:
<code>x</code> contains <code>"hello"</code> or contains
<code>"(world"</code>, and contains <code>"my lady)"</code>. The two
latter are invalid regexes but can make sense if you have the flag
“fixed” turned on. To escape the meaning of the logical operators, see
the <a href="#logical_escape">dedicated section</a>.</p>
<p>In general, the logical <code>"not"</code> always apply to a single
pattern and <strong>not</strong> to the full pattern. But see the <a href="#logical_flags">section on flags</a> for an exception.</p>
<div class="section level4">
<h4 id="logical_escape">Escaping the meaning of the logical operators<a class="anchor" aria-label="anchor" href="#logical_escape"></a>
</h4>
<p>To escape the meaning of the logical operators, there are two
solutions to escape them:</p>
<ul>
<li>use two backslashes just before the operator:
<code>"a \\&amp; b"</code> means <code>x</code> contains
<code>"a &amp; b"</code>
</li>
<li>use a regex hack: the previous example is equivalent to
<code>"a [&amp;] b"</code> in regex parlance and won’t be parsed as a
logical AND</li>
</ul>
</div>
<div class="section level4">
<h4 id="logical_flags">How do regex flags work with logically combined regexes?<a class="anchor" aria-label="anchor" href="#logical_flags"></a>
</h4>
<p>When you add flags to a pattern, these apply to <em>all</em> regex
sub-patterns. This means that <code>"f/( | )"</code> treats the two
parentheses as “fixed”. <em>You cannot add flags specific to a single
sub-pattern.</em></p>
<p>The functions <code>str_is</code>, <code>str_which</code> and
<code>str_get</code> accept a negation before the flags (they’re the
only ones).<br>
In that case, the result of all the sub-patterns is negated. You can add
the empty flag to make this work without flags. For example
<code>"!/a &amp; b &amp; c"</code> means <code>x</code> does not contain
(<code>a</code> AND <code>b</code> AND <code>c</code>).</p>
</div>
</div>
<div class="section level3">
<h3 id="detect_funs">Pattern detection with <code>str_is</code>, <code>str_which</code>
and <code>str_get</code><a class="anchor" aria-label="anchor" href="#detect_funs"></a>
</h3>
<p>Use <code>str_is</code>, <code>str_which</code> and
<code>str_get</code> to detect patterns in character vectors and obtain
either a logical vector, an integer vector, or the values.</p>
<p>In this section we give examples for <code>str_get</code> which
hopefully will be explicit enough to illustrate how it works. For the
record, <code>str_get</code> uses <code>str_is</code> internally so
these examples are equivalent with <code>str_is</code> or
<code>str_which</code>.</p>
<p>Ex.1: series of examples using the <em>recommended syntax</em>.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cars</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/row.names.html" class="external-link">row.names</a></span><span class="op">(</span><span class="va">mtcars</span><span class="op">)</span></span>
<span><span class="fu">smagic</span><span class="op">(</span><span class="st">"All cars from mtcars:\n{C, 60 width ? cars}"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "All cars from mtcars:\nMazda RX4, Mazda RX4 Wag, Datsun 710, Hornet 4 Drive, Hornet\nSportabout, Valiant, Duster 360, Merc 240D, Merc 230, Merc\n280, Merc 280C, Merc 450SE, Merc 450SL, Merc 450SLC,\nCadillac Fleetwood, Lincoln Continental, Chrysler Imperial,\nFiat 128, Honda Civic, Toyota Corolla, Toyota Corona, Dodge\nChallenger, AMC Javelin, Camaro Z28, Pontiac Firebird, Fiat\nX1-9, Porsche 914-2, Lotus Europa, Ford Pantera L, Ferrari\nDino, Maserati Bora and Volvo 142E"</span></span>
<span></span>
<span><span class="co"># cars with an 'a', an 'e', an 'i', and an 'o', all in lower case</span></span>
<span><span class="fu"><a href="../reference/str_get.html">str_get</a></span><span class="op">(</span><span class="va">cars</span>, <span class="st">"a &amp; e &amp; i &amp; o"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Cadillac Fleetwood"  "Lincoln Continental" "Pontiac Firebird"   </span></span>
<span><span class="co">#&gt; [4] "Ferrari Dino"        "Maserati Bora"</span></span>
<span></span>
<span><span class="co"># cars with no 'e' and at least one digit</span></span>
<span><span class="fu"><a href="../reference/str_get.html">str_get</a></span><span class="op">(</span><span class="va">cars</span>, <span class="st">"!e &amp; \\d"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Mazda RX4"     "Mazda RX4 Wag" "Datsun 710"    "Fiat 128"     </span></span>
<span><span class="co">#&gt; [5] "Camaro Z28"    "Fiat X1-9"     "Volvo 142E"</span></span>
<span></span>
<span><span class="co"># we use the empty flag trick to negate the full pattern</span></span>
<span><span class="co"># NOT(cars with an 'e' AND one digit)</span></span>
<span><span class="fu"><a href="../reference/str_get.html">str_get</a></span><span class="op">(</span><span class="va">cars</span>, <span class="st">"!/e &amp; \\d"</span><span class="op">)</span></span>
<span><span class="co">#&gt;  [1] "Mazda RX4"           "Mazda RX4 Wag"       "Datsun 710"         </span></span>
<span><span class="co">#&gt;  [4] "Hornet Sportabout"   "Valiant"             "Cadillac Fleetwood" </span></span>
<span><span class="co">#&gt;  [7] "Lincoln Continental" "Chrysler Imperial"   "Fiat 128"           </span></span>
<span><span class="co">#&gt; [10] "Honda Civic"         "Toyota Corolla"      "Toyota Corona"      </span></span>
<span><span class="co">#&gt; [13] "Dodge Challenger"    "AMC Javelin"         "Camaro Z28"         </span></span>
<span><span class="co">#&gt; [16] "Pontiac Firebird"    "Fiat X1-9"           "Lotus Europa"       </span></span>
<span><span class="co">#&gt; [19] "Ford Pantera L"      "Ferrari Dino"        "Maserati Bora"      </span></span>
<span><span class="co">#&gt; [22] "Volvo 142E"</span></span>
<span></span>
<span><span class="co"># flags apply to all</span></span>
<span><span class="co"># contains the 'words' 2, 9 or l</span></span>
<span><span class="co"># alternative syntax for flags: "wi/2 | 9 | l"</span></span>
<span><span class="fu"><a href="../reference/str_get.html">str_get</a></span><span class="op">(</span><span class="va">cars</span>, <span class="st">"word, ignore/2 | 9 | l"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Fiat X1-9"      "Porsche 914-2"  "Ford Pantera L"</span></span></code></pre></div>
<p>The default syntax is <code>str_get(x, ...)</code> (same for
<code>str_is</code> and <code>str_which</code>), where <code>...</code>
contains any number of patterns to detect. By default the results of
these pattern detections are combined with a logical AND. To combine
them with a logical OR, you need to use the argument
<code>or = TRUE</code>. You can also pass the flags as regular function
arguments. They then apply to all patterns.</p>
<p>Ex.2: replication of Ex.1 using an alternative syntax.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># str_get(cars, "a &amp; e &amp; i &amp; o")</span></span>
<span><span class="co"># cars with an 'a', an 'e', an 'i', and an 'o', all in lower case</span></span>
<span><span class="fu"><a href="../reference/str_get.html">str_get</a></span><span class="op">(</span><span class="va">cars</span>, <span class="st">"a"</span>, <span class="st">"e"</span>, <span class="st">"i"</span>, <span class="st">"o"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Cadillac Fleetwood"  "Lincoln Continental" "Pontiac Firebird"   </span></span>
<span><span class="co">#&gt; [4] "Ferrari Dino"        "Maserati Bora"</span></span>
<span></span>
<span><span class="co"># str_get(cars, "!e &amp; \\d")</span></span>
<span><span class="co"># cars with no 'e' and at least one digit</span></span>
<span><span class="fu"><a href="../reference/str_get.html">str_get</a></span><span class="op">(</span><span class="va">cars</span>, <span class="st">"!e"</span>, <span class="st">"\\d"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Mazda RX4"     "Mazda RX4 Wag" "Datsun 710"    "Fiat 128"     </span></span>
<span><span class="co">#&gt; [5] "Camaro Z28"    "Fiat X1-9"     "Volvo 142E"</span></span>
<span></span>
<span><span class="co"># str_get(cars, "!/e &amp; \\d")</span></span>
<span><span class="co"># This example cannot be replicated directly, we need to apply logical equivalence</span></span>
<span><span class="fu"><a href="../reference/str_get.html">str_get</a></span><span class="op">(</span><span class="va">cars</span>, <span class="st">"!e"</span>, <span class="st">"!\\d"</span>, or <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt;  [1] "Mazda RX4"           "Mazda RX4 Wag"       "Datsun 710"         </span></span>
<span><span class="co">#&gt;  [4] "Hornet Sportabout"   "Valiant"             "Cadillac Fleetwood" </span></span>
<span><span class="co">#&gt;  [7] "Lincoln Continental" "Chrysler Imperial"   "Fiat 128"           </span></span>
<span><span class="co">#&gt; [10] "Honda Civic"         "Toyota Corolla"      "Toyota Corona"      </span></span>
<span><span class="co">#&gt; [13] "Dodge Challenger"    "AMC Javelin"         "Camaro Z28"         </span></span>
<span><span class="co">#&gt; [16] "Pontiac Firebird"    "Fiat X1-9"           "Lotus Europa"       </span></span>
<span><span class="co">#&gt; [19] "Ford Pantera L"      "Ferrari Dino"        "Maserati Bora"      </span></span>
<span><span class="co">#&gt; [22] "Volvo 142E"</span></span>
<span></span>
<span><span class="co"># str_get(cars, "wi/2 | 9 | l")</span></span>
<span><span class="co"># contains the 'words' 2, 9 or l</span></span>
<span><span class="fu"><a href="../reference/str_get.html">str_get</a></span><span class="op">(</span><span class="va">cars</span>, <span class="st">"2"</span>, <span class="st">"9"</span>, <span class="st">"l"</span>, or <span class="op">=</span> <span class="cn">TRUE</span>, word <span class="op">=</span> <span class="cn">TRUE</span>, ignore.case <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Fiat X1-9"      "Porsche 914-2"  "Ford Pantera L"</span></span></code></pre></div>
<div class="section level4">
<h4 id="detect_get">Specificities of <code>srt_get</code><a class="anchor" aria-label="anchor" href="#detect_get"></a>
</h4>
<p>On top of the detection previously described, the function
<code>srt_get</code> changes its behavior with the arguments
<code>seq</code> or <code>seq.unik</code>. It also supports <a href="#get_caching">automatic caching</a>.</p>
<div class="section level5">
<h5 id="sequentially-appending-results">Sequentially appending results<a class="anchor" aria-label="anchor" href="#sequentially-appending-results"></a>
</h5>
<p>As seen previously, patterns in <code>...</code> are combined with a
logical AND. If you set <code>seq = TRUE</code>, this behavior changes.
The results of each pattern becomes stacked sequentially. Schematically,
you obtain the vector
<code>c(x_that_contains_pat1, x_that_contains_pat2, etc)</code> with
<code>pat1</code> the first pattern in <code>...</code>,
<code>pat2</code> the second pattern, etc.</p>
<p>Using <code>seq.unik = TRUE</code> is like <code>seq</code> but
applies the function <code><a href="https://rdrr.io/r/base/unique.html" class="external-link">unique()</a></code> at the end.</p>
<p>Ex: sequentially combining results.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># cars without digits, then cars with 2 'a's or 2 'e's and a digit</span></span>
<span><span class="fu"><a href="../reference/str_get.html">str_get</a></span><span class="op">(</span><span class="va">cars</span>, <span class="st">"!\\d"</span>, <span class="st">"i/a.+a | e.+e &amp; \\d"</span>, seq <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt;  [1] "Hornet Sportabout"   "Valiant"             "Cadillac Fleetwood" </span></span>
<span><span class="co">#&gt;  [4] "Lincoln Continental" "Chrysler Imperial"   "Honda Civic"        </span></span>
<span><span class="co">#&gt;  [7] "Toyota Corolla"      "Toyota Corona"       "Dodge Challenger"   </span></span>
<span><span class="co">#&gt; [10] "AMC Javelin"         "Pontiac Firebird"    "Lotus Europa"       </span></span>
<span><span class="co">#&gt; [13] "Ford Pantera L"      "Ferrari Dino"        "Maserati Bora"      </span></span>
<span><span class="co">#&gt; [16] "Mazda RX4"           "Mazda RX4 Wag"       "Hornet 4 Drive"     </span></span>
<span><span class="co">#&gt; [19] "Merc 450SE"          "Camaro Z28"</span></span>
<span></span>
<span><span class="co"># let's get the first word of each car name</span></span>
<span><span class="va">car_first</span> <span class="op">=</span> <span class="fu"><a href="../reference/str_ops.html">str_ops</a></span><span class="op">(</span><span class="va">cars</span>, <span class="st">"extract.first"</span><span class="op">)</span></span>
<span><span class="co"># we select car brands ending with 'a', then ending with 'i'</span></span>
<span><span class="fu"><a href="../reference/str_get.html">str_get</a></span><span class="op">(</span><span class="va">car_first</span>, <span class="st">"a$"</span>, <span class="st">"i$"</span>, seq <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Mazda"    "Mazda"    "Honda"    "Toyota"   "Toyota"   "Ferrari"  "Maserati"</span></span>
<span><span class="co"># seq.unik is similar to seq but applies unique()</span></span>
<span><span class="fu"><a href="../reference/str_get.html">str_get</a></span><span class="op">(</span><span class="va">car_first</span>, <span class="st">"a$"</span>, <span class="st">"i$"</span>, seq.unik <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Mazda"    "Honda"    "Toyota"   "Ferrari"  "Maserati"</span></span></code></pre></div>
</div>
<div class="section level5">
<h5 id="get_caching">Caching<a class="anchor" aria-label="anchor" href="#get_caching"></a>
</h5>
<p>At the exploration stage, we often run the same command with a few
variations on the same data set. Acknowledging this,
<code>str_get</code> supports the caching of the data argument in
interactive use. This means that the user can concentrate in the pattern
to find and need not bother to write the data from where to fectch the
values. Note that <code>str_get</code> is the only
<code>stringmagic</code> function to have this ability.</p>
<p>Caching is always enabled, you don’t need to do anything.</p>
<p>Ex: caching of the data.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Since we used `car_first` in the previous example, we don't need to provide</span></span>
<span><span class="co"># it explicitly now</span></span>
<span><span class="co"># =&gt; brands containing 'M' and ending with 'a' or 'i'; brands containing 'M'</span></span>
<span><span class="fu"><a href="../reference/str_get.html">str_get</a></span><span class="op">(</span><span class="st">"M &amp; [ai]$"</span>, <span class="st">"M"</span>, seq.unik <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Mazda"    "Maserati" "Merc"     "AMC"</span></span></code></pre></div>
</div>
</div>
</div>
</div>
<div class="section level2">
<h2 id="sec_ops">Chaining string operations with <code>str_ops</code><a class="anchor" aria-label="anchor" href="#sec_ops"></a>
</h2>
<p>Formatting text data often requires applying many functions (be it
for parsing, text analysis, etc). Even for simple tasks, the number of
operations can quickly balloon, adding many lines of code, reducing
readability, and all this for basic processing.</p>
<p>The function <code>str_ops</code> tries to solve this problem. It has
access to all (50+) <a href="https://lrberge.github.io/stringmagic/articles/smagic_walkthrough.html#sec_operations_reference" class="external-link"><code>smagic</code>
operations</a>, allowing for a compact and readable way to chain basic
operations on character strings.</p>
<p>Below are a few motivating examples.</p>
<p>Ex.1: Parsing data.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># parsing an input: extracting the numbers</span></span>
<span><span class="va">input</span> <span class="op">=</span> <span class="st">"8.5in, 5.5, .5 cm"</span></span>
<span><span class="fu"><a href="../reference/str_ops.html">str_ops</a></span><span class="op">(</span><span class="va">input</span>, <span class="st">"','s, tws, '^\\. =&gt; 0.'r, '^\\D+|\\D+$'r, num"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 8.5 5.5 0.5</span></span>
<span><span class="co"># Explanation------------------------------------------------------------------|</span></span>
<span><span class="co"># ','s: splitting w.r.t. ','                                                   |</span></span>
<span><span class="co"># tws: trimming the whitespaces                                                |</span></span>
<span><span class="co"># '^\\. =&gt; 0.'r: adds a 0 to strings starting with '.'                         |</span></span>
<span><span class="co"># '^\\D+|\\D+$'r: removes non-digits on both ends of the string                |</span></span>
<span><span class="co"># num: converts to numeric                                                     |</span></span>
<span></span>
<span><span class="co"># now extracting the units</span></span>
<span><span class="fu"><a href="../reference/str_ops.html">str_ops</a></span><span class="op">(</span><span class="va">input</span>, <span class="st">"','s, '^[ \\d.]+'r, tws"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "in" ""   "cm"</span></span>
<span><span class="co"># Explanation------------------------------------------------------------------|</span></span>
<span><span class="co"># ','s: splitting w.r.t. ','                                                   |</span></span>
<span><span class="co"># '^[ \\d.]+'r: removes the ' ', digit and '.' at the beginning of the string  |</span></span>
<span><span class="co"># tws: trimming the whitespaces                                                |</span></span></code></pre></div>
<p>Ex.2: extracing information from text.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Now using the car data</span></span>
<span><span class="va">cars</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/row.names.html" class="external-link">row.names</a></span><span class="op">(</span><span class="va">mtcars</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># let's get the brands starting with an "m"</span></span>
<span><span class="fu"><a href="../reference/str_ops.html">str_ops</a></span><span class="op">(</span><span class="va">cars</span>, <span class="st">"'i/^m'get, x, unik"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Mazda"    "Merc"     "Maserati"</span></span>
<span><span class="co"># Explanation------------------------------------------------------------------|</span></span>
<span><span class="co"># 'i/^m'get: keeps only the elements starting with an m,                       |</span></span>
<span><span class="co">#            i/ is the 'regex-flag' "ignore" to ignore the case                |</span></span>
<span><span class="co">#            ^m means "starts with an m" in regex language                     |</span></span>
<span><span class="co"># x: extracts the first pattern. The default pattern is "[[:alnum:]]+"         |</span></span>
<span><span class="co">#    which means an alpha-numeric word                                         |</span></span>
<span><span class="co"># unik: applies unique() to the vector                                         |</span></span>
<span></span>
<span><span class="co"># let's get the 3 largest numbers appearing in the car models</span></span>
<span><span class="fu"><a href="../reference/str_ops.html">str_ops</a></span><span class="op">(</span><span class="va">cars</span>, <span class="st">"'\\d+'x, rm, unik, num, dsort, 3 first"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 914 710 450</span></span>
<span><span class="co"># Explanation------------------------------------------------------------------|</span></span>
<span><span class="co"># '\\d+'x: extracts the first pattern, the pattern meaning "a succession"      |</span></span>
<span><span class="co">#          of digits in regex language                                         |</span></span>
<span><span class="co"># rm: removes elements equal to the empty string (default behavior)            |</span></span>
<span><span class="co"># unik: applies unique() to the vector                                         |</span></span>
<span><span class="co"># num: converts to numeric                                                     |</span></span>
<span><span class="co"># dsort: sorts in decreasing order                                             |</span></span>
<span><span class="co"># 3 first: keeps only the first three element                                  |</span></span></code></pre></div>
<p>As you can see, an operation that would take multiple lines to read
and understand now can be read from left to right in a single line.</p>
</div>
<div class="section level2">
<h2 id="sec_clean">
<code>str_clean</code>: One function to clean them all<a class="anchor" aria-label="anchor" href="#sec_clean"></a>
</h2>
<p>The function <code>str_clean</code> streamlines the cleaning of
character vectors by providing:</p>
<ul>
<li><ol style="list-style-type: lower-roman">
<li>a specialized syntax to replace multiple regex patterns,</li>
</ol></li>
<li><ol start="2" style="list-style-type: lower-roman">
<li>a direct access to many low level string operations, and</li>
</ol></li>
<li><ol start="3" style="list-style-type: lower-roman">
<li>the ability to chain these two operations.</li>
</ol></li>
</ul>
<div class="section level3">
<h3 id="cleaning-syntax">Cleaning syntax<a class="anchor" aria-label="anchor" href="#cleaning-syntax"></a>
</h3>
<p>This function is of the form <code>str_clean(x, ...)</code> with
<code>x</code> the vector to clean and <code>...</code> any number of
cleaning operations which can be of two types:</p>
<ol style="list-style-type: decimal">
<li>use <code>"pat1, pat2 =&gt; replacement"</code> to replace the regex
patterns <code>pat1</code> and <code>pat2</code> with the value
<code>replacement</code>.</li>
<li>use <code>"@op1, op2"</code> to perform any arbitrary sequence of <a href="https://lrberge.github.io/stringmagic/articles/smagic_walkthrough.html#sec_operations_reference" class="external-link"><code>smagic</code>
operation</a>
</li>
</ol>
<p>In the operation <code>"pat1, pat2 =&gt; replacement"</code>, the
pattern is first split with respect to the pipe, <code>" =&gt; "</code>
(change it with argument <code>pipe</code>), to get
<code>replacement</code>. Then the pattern is split with respect to
commas (i.e. <code>",[ \t\n]+"</code>, change it with argument
<code>sep</code>) to get <code>pat1</code> and <code>pat2</code>. A
sequence of <code><a href="https://rdrr.io/r/base/grep.html" class="external-link">base::gsub</a></code> calls is performed to replace each
<code>patx</code> with <code>replacement</code>.</p>
<p>By default the replacement is the empty string. This means that
writting <code>"pat1, pat2"</code> will lead to erasing these two
patterns.</p>
<p>If a pattern starts with an <code>"@"</code>, the subsequent
character string is sent to <code>str_ops</code>. For example
<code>"@ascii, lower"</code> is equivalent to
<code>str_ops(x, "ascii, lower")</code> which turns <code>x</code> to
ASCII and lowers the case.</p>
</div>
<div class="section level3">
<h3 id="clean_example">Example of text cleaning<a class="anchor" aria-label="anchor" href="#clean_example"></a>
</h3>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">monologue</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"For who would bear the whips and scorns of time"</span>,</span>
<span>              <span class="st">"Th' oppressor's wrong, the proud man's contumely,"</span>,</span>
<span>              <span class="st">"The pangs of despis'd love, the law's delay,"</span>,</span>
<span>              <span class="st">"The insolence of office, and the spurns"</span>,</span>
<span>              <span class="st">"That patient merit of th' unworthy takes,"</span>,</span>
<span>              <span class="st">"When he himself might his quietus make"</span>,</span>
<span>              <span class="st">"With a bare bodkin? Who would these fardels bear,"</span>,</span>
<span>              <span class="st">"To grunt and sweat under a weary life,"</span>,</span>
<span>              <span class="st">"But that the dread of something after death-"</span>,</span>
<span>              <span class="st">"The undiscover'd country, from whose bourn"</span>,</span>
<span>              <span class="st">"No traveller returns- puzzles the will,"</span>,</span>
<span>              <span class="st">"And makes us rather bear those ills we have"</span>,</span>
<span>              <span class="st">"Than fly to others that we know not of?"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Cleaning a text</span></span>
<span><span class="fu"><a href="../reference/str_clean.html">str_clean</a></span><span class="op">(</span><span class="va">monologue</span>, </span>
<span>          <span class="co"># use smagic to: lower the case and remove basic stopwords</span></span>
<span>          <span class="st">"@lower, stopword"</span>,</span>
<span>          <span class="co"># remove a few extra stopwords(we use the flag word 'w/')</span></span>
<span>          <span class="st">"w/th, 's"</span>,</span>
<span>          <span class="co"># manually stem some verbs</span></span>
<span>          <span class="st">"despis'd =&gt; despise"</span>, <span class="st">"undiscover'd =&gt; undiscover"</span>, <span class="st">"(m|t)akes =&gt; \\1ake"</span>,</span>
<span>          <span class="co"># still stemming: dropping the ending 's' for words of 4+ letters, except for quietus</span></span>
<span>          <span class="st">"(\\w{3,}[^u])s\\b =&gt; \\1"</span>,</span>
<span>          <span class="co"># normalizing the whitespaces + removing punctuation</span></span>
<span>          <span class="st">"@ws.punct"</span><span class="op">)</span></span>
<span><span class="co">#&gt;  [1] "bear whip scorn time"                "oppressor wrong proud man contumely"</span></span>
<span><span class="co">#&gt;  [3] "pang despise love law delay"         "insolence office spurn"             </span></span>
<span><span class="co">#&gt;  [5] "patient merit unworthy take"         "might quietus make"                 </span></span>
<span><span class="co">#&gt;  [7] "bare bodkin fardel bear"             "grunt sweat weary life"             </span></span>
<span><span class="co">#&gt;  [9] "dread something death"               "undiscover country whose bourn"     </span></span>
<span><span class="co">#&gt; [11] "traveller return puzzle will"        "make us rather bear ills"           </span></span>
<span><span class="co">#&gt; [13] "fly other know"</span></span></code></pre></div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Laurent R Berge.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
