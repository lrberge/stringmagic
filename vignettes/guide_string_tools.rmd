---
title: "String tools: magic edition"
author: "Laurent R. BergÃ©"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: journal
    highlight: haddock
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: no
      smooth_scroll: no
  pdf_document:
    toc: yes
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{string_tools}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

# we preload it to avoid ugly (was comiled with R.x.x) warnings in the doc
library(stringmagic)

options("smagic_string_get_forced_caching" = TRUE)
```

This vignette describes `stringmagic` tools for handling character vectors. 
For a quick start, here are the sections describing:

- how to [detect complex regex (=regular expression) patterns](#detect_funs)
- how to easily, and clearly, [chain multiple string operations](#sec_ops)
- how to efficiently, and clearly, [clean character strings](#sec_clean)

# Intuivite detection of regex patterns

Detecting a single regex pattern is pretty straightforward with regular tools
like `base::grepl` or `stringr::string_detect`. Things become more complicated
when we want to detect the presence of multiple patterns. 

`stringmagic` offers three functions with an intuitive syntax to deal with 
complex pattern detection:

- [string_is](#detect_funs): returns a logical vector
- [string_which](#detect_funs): returns the indexes of the matches
- [string_get](#detect_funs): returns the matches

As described in the next section., these tools benefit from a streamlined syntax to 
logically combine several regex patterns. 



## Pattern detection with `string_is`, `string_which` and `string_get` {#detect_funs}

Use `string_is`, `string_which` and `string_get` to detect patterns in character vectors and obtain either 
a logical vector, an integer vector, or the values.

In this section we give examples for `string_get` which hopefully will be explicit 
enough to illustrate how it works. For the record, `string_get` uses `string_is` internally so
these examples are equivalent with `string_is` or `string_which`. 

Ex.1: series of examples using the *recommended syntax*.
```{r}
cars = row.names(mtcars)
smagic("All cars from mtcars:\n{C, 60 width ? cars}")

# cars with an 'a', an 'e', an 'i', and an 'o', all in lower case
string_get(cars, "a & e & i & o")

# cars with no 'e' and at least one digit
string_get(cars, "!e & \\d")

# flags apply to all
# contains the 'words' 2, 9 or l
# alternative syntax for flags: "wi/2 | 9 | l"
string_get(cars, "word, ignore/2 | 9 | l")
```

The default syntax is `string_get(x, ...)` (same for `string_is` and `string_which`), 
where `...` contains any number of patterns
to detect. By default the results of these pattern detections are combined with 
a logical AND. To combine them with a logical OR, you need to use the argument
`or = TRUE`. You can also pass the flags as regular function arguments. They then
apply to all patterns.

Ex.2: replication of Ex.1 using an alternative syntax.
```{r}
# string_get(cars, "a & e & i & o")
# cars with an 'a', an 'e', an 'i', and an 'o', all in lower case
string_get(cars, "a", "e", "i", "o")

# string_get(cars, "!e & \\d")
# cars with no 'e' and at least one digit
string_get(cars, "!e", "\\d")

# string_get(cars, "!/e & \\d")
# This example cannot be replicated directly, we need to apply logical equivalence
string_get(cars, "!e", "!\\d", or = TRUE)

# string_get(cars, "wi/2 | 9 | l")
# contains the 'words' 2, 9 or l
string_get(cars, "2", "9", "l", or = TRUE, word = TRUE, ignore.case = TRUE)
```

### Specificities of `srt_get` {#detect_get}

On top of the detection previously described, the function `srt_get` changes its 
behavior with the arguments `seq` or `seq.unik`. It also supports [automatic caching](#get_caching).

#### Sequentially appending results

As seen previously, patterns in `...` are combined with a logical AND. If you set
`seq = TRUE`, this behavior changes. The results of each pattern becomes stacked 
sequentially. Schematically, you obtain the vector `c(x_that_contains_pat1, x_that_contains_pat2, etc)`
with `pat1` the first pattern in `...`, `pat2` the second pattern, etc.

Using `seq.unik = TRUE` is like `seq` but applies the function `unique()` at the end.

Ex: sequentially combining results.
```{r}
# cars without digits, then cars with 2 'a's or 2 'e's and a digit
string_get(cars, "!\\d", "i/a.+a | e.+e & \\d", seq = TRUE)

# let's get the first word of each car name
car_first = string_ops(cars, "extract.first")
# we select car brands ending with 'a', then ending with 'i'
string_get(car_first, "a$", "i$", seq = TRUE)
# seq.unik is similar to seq but applies unique()
string_get(car_first, "a$", "i$", seq.unik = TRUE)
```

#### Caching {#get_caching}

At the exploration stage, we often run the same command with a few
variations on the same data set. Acknowledging this, `string_get` supports the caching
of the data argument in interactive use. This means that the user can concentrate in
the pattern to find and need not bother to write the data from where to fectch the
values. Note that `string_get` is the only `stringmagic` function to have this
ability.

Caching is always enabled, you don't need to do anything.

Ex: caching of the data.
```{r}
# Since we used `car_first` in the previous example, we don't need to provide
# it explicitly now
# => brands containing 'M' and ending with 'a' or 'i'; brands containing 'M'
string_get("M & [ai]$", "M", seq.unik = TRUE)
```

# Chaining string operations with `string_ops` {#sec_ops}

Formatting text data often requires applying many functions
(be it for parsing, text analysis, etc). 
Even for simple tasks, the number of operations can quickly balloon, adding many
lines of code, reducing readability, and all this for basic processing.

The function `string_ops` tries to solve this problem. 
It has access to all (50+) [`smagic` operations](https://lrberge.github.io/stringmagic/articles/smagic_walkthrough.html#sec_operations_reference), allowing for
a compact and readable way to chain basic operations on character strings.

Below are a few motivating examples.

Ex.1: Parsing data.
```{r}
# parsing an input: extracting the numbers
input = "8.5in, 5.5, .5 cm"
string_ops(input, "','s, tws, '^\\. => 0.'r, '^\\D+|\\D+$'r, num")
# Explanation------------------------------------------------------------------|
# ','s: splitting w.r.t. ','                                                   |
# tws: trimming the whitespaces                                                |
# '^\\. => 0.'r: adds a 0 to strings starting with '.'                         |
# '^\\D+|\\D+$'r: removes non-digits on both ends of the string                |
# num: converts to numeric                                                     |

# now extracting the units
string_ops(input, "','s, '^[ \\d.]+'r, tws")
# Explanation------------------------------------------------------------------|
# ','s: splitting w.r.t. ','                                                   |
# '^[ \\d.]+'r: removes the ' ', digit and '.' at the beginning of the string  |
# tws: trimming the whitespaces                                                |
```

Ex.2: extracing information from text.
```{r}
# Now using the car data
cars = row.names(mtcars)

# let's get the brands starting with an "m"
string_ops(cars, "'i/^m'get, x, unik")
# Explanation------------------------------------------------------------------|
# 'i/^m'get: keeps only the elements starting with an m,                       |
#            i/ is the 'regex-flag' "ignore" to ignore the case                |
#            ^m means "starts with an m" in regex language                     |
# x: extracts the first pattern. The default pattern is "[[:alnum:]]+"         |
#    which means an alpha-numeric word                                         |
# unik: applies unique() to the vector                                         |

# let's get the 3 largest numbers appearing in the car models
string_ops(cars, "'\\d+'x, rm, unik, num, dsort, 3 first")
# Explanation------------------------------------------------------------------|
# '\\d+'x: extracts the first pattern, the pattern meaning "a succession"      |
#          of digits in regex language                                         |
# rm: removes elements equal to the empty string (default behavior)            |
# unik: applies unique() to the vector                                         |
# num: converts to numeric                                                     |
# dsort: sorts in decreasing order                                             |
# 3 first: keeps only the first three element                                  |
```

As you can see, an operation that would take multiple lines to read and understand
now can be read from left to right in a single line.

# `string_clean`: One function to clean them all {#sec_clean}

The function `string_clean` streamlines the cleaning of character vectors by providing:

- i) a specialized syntax to replace multiple regex patterns, 
- ii) a direct access to many low level string operations, and 
- iii) the ability to chain these two operations. 

## Cleaning syntax

This function is of the form `string_clean(x, ...)` with `x` the vector to clean and
`...` any number of cleaning operations which can be of two types:

1. use `"pat1, pat2 => replacement"` to replace the regex patterns `pat1` and `pat2` 
with the value `replacement`.
1. use `"@op1, op2"` to perform any arbitrary sequence of [`smagic` operation](https://lrberge.github.io/stringmagic/articles/smagic_walkthrough.html#sec_operations_reference)

In the operation `"pat1, pat2 => replacement"`, the pattern is first split with respect
to the pipe, `" => "` (change it with argument `pipe`), to get `replacement`. 
Then the pattern is split with respect to commas (i.e. `",[ \t\n]+"`, change it with argument `sep`) 
to get `pat1` and `pat2`. A sequence of `base::gsub` calls is performed to replace each
`patx` with `replacement`. 

By default the replacement is the empty string. This means that writting `"pat1, pat2"`
will lead to erasing these two patterns.

If a pattern starts with an `"@"`, the subsequent character string is sent to `string_ops`.
For example `"@ascii, lower"` is equivalent to `string_ops(x, "ascii, lower")` which 
turns `x` to ASCII and lowers the case. 

## Example of text cleaning {#clean_example}

```{r}
monologue = c("For who would bear the whips and scorns of time",
              "Th' oppressor's wrong, the proud man's contumely,",
              "The pangs of despis'd love, the law's delay,",
              "The insolence of office, and the spurns",
              "That patient merit of th' unworthy takes,",
              "When he himself might his quietus make",
              "With a bare bodkin? Who would these fardels bear,",
              "To grunt and sweat under a weary life,",
              "But that the dread of something after death-",
              "The undiscover'd country, from whose bourn",
              "No traveller returns- puzzles the will,",
              "And makes us rather bear those ills we have",
              "Than fly to others that we know not of?")

# Cleaning a text
string_clean(monologue, 
          # use smagic to: lower the case and remove basic stopwords
          "@lower, stopword",
          # remove a few extra stopwords(we use the flag word 'w/')
          "w/th, 's",
          # manually stem some verbs
          "despis'd => despise", "undiscover'd => undiscover", "(m|t)akes => \\1ake",
          # still stemming: dropping the ending 's' for words of 4+ letters, except for quietus
          "(\\w{3,}[^u])s\\b => \\1",
          # normalizing the whitespaces + removing punctuation
          "@ws.punct")

```


